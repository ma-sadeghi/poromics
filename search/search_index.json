{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Poromics documentation","text":""},{"location":"#what-is-poromics","title":"What is Poromics?","text":"<p>Poromics is an open-source Python package for estimation of transport properties of 2D/3D images of porous materials. The main design philosophies driving Poromics are speed and ease of use. Poromics is developed alongside the Julia library Tortuosity.jl, which serves as its tortuosity simulation engine.</p> <p>The goal is to support more transport properties in the future such as permeability, transient tortuosity, etc. Poromics is GPU-compatible right out of the box, which can significantly speed up the calculations for large images (up to 50x speedup).</p> <p></p> <p>A typical workflow for estimating tortuosity. The user loads a 2D/3D image of a porous material and specifies an axis. Poromics then performs a steady-state diffusion simulation along the specified axis to compute the tortuosity from the concentration profile <sup>1</sup>.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> Add support for more transport properties<ul> <li> Diffusional tortuosity</li> <li> Electrode tortuosity</li> <li> Transient tortuosity</li> <li> Permeability</li> </ul> </li> <li> Add command-line interface (CLI) for easy usage</li> <li> Add support for sysimage creation upon installation for faster startup</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to Poromics! If you have any ideas, suggestions, or bug reports, please open an issue or submit a pull request. For more information on how to contribute, please refer to the contributing guide, or simply open an issue or a pull request on GitHub.</p> <ol> <li> <p>Image from: Fu, J., Thomas, H. R., &amp; Li, C. (2021). Tortuosity of porous media: Image analysis and physical simulation. Earth-Science Reviews, 212, 103439. (Figure 9)\u00a0\u21a9</p> </li> </ol>"},{"location":"contributing/","title":"Contributing to Poromics","text":"<p>Poromics is a collection of tools to rapidly estimate transport properties of 2D/3D images of porous materials. We use Poromics regularly in our research, and we hope you will too. The package is open-source, and we welcome contributions from the community. This document describes how to get involved.</p> <p>Before you start you'll need to set up a free GitHub account and sign in. Here are some instructions to get started.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"contributing/#open-a-new-issue","title":"Open a New Issue","text":"<p>We use Github to track issues. Issues can take the form of:</p> <p>(a) bug reports such as a function producing an error or odd result in some circumstances.</p> <p>(b) feature requests such a suggesting a new function be added to the package, presumably based on some literature report that describes it, or enhancements to an existing function.</p> <p>(c) general usage questions where the documentation is not clear and you need help getting a function to work as desired. This is actually a bug report in disguise since it means there is a problem with the documentation.</p>"},{"location":"contributing/#addressing-open-issues","title":"Addressing Open Issues","text":"<p>Help fixing open issues is always welcome; however, the learning curve for submitting new code to any repo on Github is a bit intimidating. The process is as follows:</p> <p>a) Fork Poromics to your own Github account. This lets you work on the code since you are the owner of that forked copy.</p> <p>b) Pull the code to your local machine using some Git client. We suggest GitKraken. For help using the Git version control system, see these resources.</p> <p>c) Create a new branch, with a useful name like \"fix_issue_41\" or \"add_awesome_solver\", then checkout that branch.</p> <p>d) Edit the code as desired, either fixing or adding something. You'll need to know Python and the various packages in the SciPy stack for this part.</p> <p>e) Push the changes back to Github, to your own repo.</p> <p>f) Navigate to the pull requests area on the Poromics repo, then click the \"new pull request\" button. As the name suggests, you are requesting us to pull your code in to our repo. You'll want to select the correct branch on your repo (e.g. \"add_awesome_filter\") and the \"dev\" branch on Poromics.</p> <p>g) This will trigger several things on our repo, including most importantly a conversation between you and the Poromics team about your code. After any fine-tuning is done, we will merge your code into Poromics, and your contribution will be immortalized in Poromics.</p> <p>Note</p> <p>Adapted from PoreSpy's contributing guide.</p>"},{"location":"install/","title":"Installation","text":"<p>To install <code>poromics</code>, you can use <code>pip</code>, but we highly recommend using <code>uv</code> instead, as it is significantly faster. <code>uv</code> is a drop-in replacement for <code>pip</code>, so you can use it in the same way.</p>"},{"location":"install/#using-uv","title":"Using <code>uv</code>","text":"<ol> <li>Install <code>uv</code>.</li> <li>Create a virtual environment (or activate an existing one, e.g., <code>conda</code> or <code>pyenv</code>)</li> <li>Run the following command in a terminal/command prompt:</li> </ol> <pre><code>uv pip install poromics\n</code></pre>"},{"location":"install/#using-pip","title":"Using <code>pip</code>","text":"<ol> <li>Create a virtual environment (or activate an existing one, e.g., <code>conda</code> or <code>pyenv</code>)</li> <li>Run the following command in a terminal/command prompt:</li> </ol> <pre><code>pip install poromics\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This page contains the API reference for the <code>poromics</code> package.</p> Main (<code>poromics</code>) <p>The main module of the <code>poromics</code> package provides the core functionality for calculating tortuosity and other transport properties.</p> Julia helpers (<code>poromics.julia_helpers</code>) <p>The <code>poromics.julia_helpers</code> module provides helper functions for interacting with Julia and the <code>Tortuosity.jl</code> package. These functions are used internally by the main module to perform calculations. Feel free to explore them if you're interested in the implementation details.</p>"},{"location":"reference/#poromics.tortuosity_fd","title":"<code>tortuosity_fd(im, *, axis, D=None, rtol=1e-05, gpu=False, verbose=False)</code>","text":"<p>Performs a tortuosity simulation on the given image along the specified axis.</p> <p>The function removes non-percolating paths from the image before performing the tortuosity calculation.</p> <p>Parameters:</p> Name Type Description Default <code>im</code> <code>ndarray</code> <p>The input image.</p> required <code>axis</code> <code>int</code> <p>The axis along which to compute tortuosity (0=x, 1=y, 2=z).</p> required <code>D</code> <code>ndarray</code> <p>Diffusivity field. If None, a uniform diffusivity of 1.0 is assumed.</p> <code>None</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for the solver.</p> <code>1e-05</code> <code>gpu</code> <code>bool</code> <p>If True, use GPU for computation.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If True, print additional information during the solution process.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>result</code> <code>Result</code> <p>An object containing the boolean image, axis, tortuosity, and concentration.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no percolating paths are found along the specified axis.</p> Source code in <code>src/poromics/_metrics.py</code> <pre><code>def tortuosity_fd(\n    im,\n    *,\n    axis: int,\n    D: np.ndarray = None,\n    rtol: float = 1e-5,\n    gpu: bool = False,\n    verbose: bool = False,\n) -&gt; Result:\n    \"\"\"\n    Performs a tortuosity simulation on the given image along the specified axis.\n\n    The function removes non-percolating paths from the image before performing\n    the tortuosity calculation.\n\n    Args:\n        im (ndarray): The input image.\n        axis (int): The axis along which to compute tortuosity (0=x, 1=y, 2=z).\n        D (ndarray): Diffusivity field. If None, a uniform diffusivity of 1.0 is assumed.\n        rtol (float): Relative tolerance for the solver.\n        gpu (bool): If True, use GPU for computation.\n        verbose (bool): If True, print additional information during the solution process.\n\n    Returns:\n        result: An object containing the boolean image, axis, tortuosity, and\n            concentration.\n\n    Raises:\n        RuntimeError: If no percolating paths are found along the specified axis.\n    \"\"\"\n    axis_jl = _jl.Symbol([\"x\", \"y\", \"z\"][axis])\n    eps0 = _taujl.Imaginator.phase_fraction(im)\n    im = np.array(_taujl.Imaginator.trim_nonpercolating_paths(im, axis=axis_jl))\n    if _jl.sum(im) == 0:\n        raise RuntimeError(\"No percolating paths along the given axis found in the image.\")\n    eps = _taujl.Imaginator.phase_fraction(im)\n    if eps[1] != eps0[1]:\n        # Trim the diffusivity field as well\n        if D is not None:\n            D[~im] = 0.0\n        logger.warning(\"The image has been trimmed to ensure percolation.\")\n    sim = _taujl.TortuositySimulation(im, D=D, axis=axis_jl, gpu=gpu)\n    sol = _taujl.solve(sim.prob, _taujl.KrylovJL_CG(), verbose=verbose, reltol=rtol)\n    c = _taujl.vec_to_grid(sol.u, im)\n    tau = _taujl.tortuosity(c, axis=axis_jl, D=D)\n    D_eff = _taujl.effective_diffusivity(c, axis=axis_jl, D=D)\n    return Result(np.asarray(im), axis, tau, D_eff, np.asarray(c), D)\n</code></pre>"},{"location":"reference/#poromics.julia_helpers.ensure_julia_deps_ready","title":"<code>ensure_julia_deps_ready(quiet=False, retry=True)</code>","text":"<p>Ensures Julia and Tortuosity.jl are installed.</p> <p>Parameters:</p> Name Type Description Default <code>quiet</code> <code>bool</code> <p>If True, suppresses output during installation. Default is False.</p> <code>False</code> <code>retry</code> <code>bool</code> <p>If True, retries the installation if it fails. Default is True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Julia or Tortuosity.jl cannot be installed.</p> Source code in <code>src/poromics/julia_helpers.py</code> <pre><code>def ensure_julia_deps_ready(quiet: bool = False, retry: bool = True) -&gt; None:\n    \"\"\"Ensures Julia and Tortuosity.jl are installed.\n\n    Args:\n        quiet: If True, suppresses output during installation. Default is False.\n        retry: If True, retries the installation if it fails. Default is True.\n\n    Raises:\n        ImportError: If Julia or Tortuosity.jl cannot be installed.\n    \"\"\"\n\n    def _ensure_julia_deps_ready(quiet):\n        if not is_julia_installed(error=False):\n            logger.warning(\"Julia not found, installing Julia...\")\n            install_julia(quiet=quiet)\n        Main = init_julia(quiet=quiet)\n        if not is_backend_installed(Main=Main, error=False):\n            logger.warning(\"Julia dependencies not found, installing Tortuosity.jl...\")\n            install_backend(quiet=quiet)\n\n    def _reset_julia_env(quiet):\n        remove_julia_env()\n        if quiet:\n            with suppress_output():\n                juliapkg.resolve(force=True)\n        else:\n            juliapkg.resolve(force=True)\n\n    try:\n        _ensure_julia_deps_ready(quiet)\n    except Exception:\n        if retry:\n            _reset_julia_env(quiet)\n            _ensure_julia_deps_ready(quiet)\n            return\n        raise\n</code></pre>"},{"location":"reference/#poromics.julia_helpers.import_backend","title":"<code>import_backend(Main=None)</code>","text":"<p>Imports Tortuosity.jl package from Julia.</p> <p>Parameters:</p> Name Type Description Default <code>Main</code> <code>ModuleValue</code> <p>Julia Main module. Default is None. If None, the Main module will be initialized.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>backend</code> <code>ModuleValue</code> <p>Handle to the Tortuosity.jl package.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Julia is not installed or the package is not found.</p> Source code in <code>src/poromics/julia_helpers.py</code> <pre><code>def import_backend(Main: \"juliacall.ModuleValue\" = None) -&gt; \"juliacall.ModuleValue\":\n    \"\"\"Imports Tortuosity.jl package from Julia.\n\n    Args:\n        Main: Julia Main module. Default is None. If None, the Main module will\n            be initialized.\n\n    Returns:\n        backend: Handle to the Tortuosity.jl package.\n\n    Raises:\n        ImportError: If Julia is not installed or the package is not found.\n    \"\"\"\n    Main = init_julia() if Main is None else Main\n    is_backend_installed(Main=Main, error=True)\n    return import_package(\"Tortuosity\", Main)\n</code></pre>"},{"location":"reference/#poromics.julia_helpers.import_package","title":"<code>import_package(package_name, Main, error=False)</code>","text":"<p>Imports a package in Julia and returns the module.</p> <p>Parameters:</p> Name Type Description Default <code>package_name</code> <code>str</code> <p>Name of the Julia package to import.</p> required <code>Main</code> <code>ModuleValue</code> <p>Julia Main module.</p> required <code>error</code> <code>bool</code> <p>If True, raises an error if the package is not found. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>package</code> <code>ModuleValue</code> <p>Handle to the imported package.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the package is not found and error is True.</p> Source code in <code>src/poromics/julia_helpers.py</code> <pre><code>def import_package(\n    package_name: str, Main: \"juliacall.ModuleValue\", error: bool = False\n) -&gt; \"juliacall.ModuleValue\":\n    \"\"\"Imports a package in Julia and returns the module.\n\n    Args:\n        package_name: Name of the Julia package to import.\n        Main: Julia Main module.\n        error: If True, raises an error if the package is not found. Default is False.\n\n    Returns:\n        package: Handle to the imported package.\n\n    Raises:\n        ImportError: If the package is not found and error is True.\n    \"\"\"\n    from juliacall import JuliaError\n\n    try:\n        Main.seval(f\"using {package_name}\")\n        return eval(f\"Main.{package_name}\")\n    except JuliaError as e:\n        if error:\n            raise e\n    return None\n</code></pre>"},{"location":"reference/#poromics.julia_helpers.init_julia","title":"<code>init_julia(quiet=False)</code>","text":"<p>Initializes Julia and returns the Main module.</p> <p>Parameters:</p> Name Type Description Default <code>quiet</code> <code>bool</code> <p>If True, suppresses the output of Julia initialization. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Main</code> <code>ModuleValue</code> <p>The Julia Main module.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Julia is not installed.</p> Source code in <code>src/poromics/julia_helpers.py</code> <pre><code>def init_julia(quiet: bool = False) -&gt; \"juliacall.ModuleValue\":\n    \"\"\"Initializes Julia and returns the Main module.\n\n    Args:\n        quiet: If True, suppresses the output of Julia initialization. Default is False.\n\n    Returns:\n        Main: The Julia Main module.\n\n    Raises:\n        ImportError: If Julia is not installed.\n    \"\"\"\n    is_julia_installed(error=True)\n    if not can_skip_resolve():\n        logger.warning(\"Julia is installed, but needs to be resolved...\")\n    if quiet:\n        with suppress_output():\n            from juliacall import Main  # type: ignore\n    else:\n        from juliacall import Main  # type: ignore\n\n    return Main\n</code></pre>"},{"location":"reference/#poromics.julia_helpers.install_backend","title":"<code>install_backend(quiet=False)</code>","text":"<p>Installs Julia dependencies for Poromics.</p> <p>Parameters:</p> Name Type Description Default <code>quiet</code> <code>bool</code> <p>If True, suppresses output during installation. Default is False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Julia is not installed.</p> Source code in <code>src/poromics/julia_helpers.py</code> <pre><code>def install_backend(quiet: bool = False) -&gt; None:\n    \"\"\"Installs Julia dependencies for Poromics.\n\n    Args:\n        quiet: If True, suppresses output during installation. Default is False.\n\n    Raises:\n        ImportError: If Julia is not installed.\n    \"\"\"\n    is_julia_installed(error=True)\n\n    if quiet:\n        with suppress_output():\n            juliapkg.resolve()\n    else:\n        juliapkg.resolve()\n</code></pre>"},{"location":"reference/#poromics.julia_helpers.install_julia","title":"<code>install_julia(quiet=False)</code>","text":"<p>Installs Julia using juliapkg.</p> <p>Parameters:</p> Name Type Description Default <code>quiet</code> <code>bool</code> <p>If True, suppresses output during installation. Default is False.</p> <code>False</code> Source code in <code>src/poromics/julia_helpers.py</code> <pre><code>def install_julia(quiet: bool = False) -&gt; None:\n    \"\"\"Installs Julia using juliapkg.\n\n    Args:\n        quiet: If True, suppresses output during installation. Default is False.\n    \"\"\"\n    # Importing juliacall automatically installs Julia using juliapkg\n    if quiet:\n        with suppress_output():\n            import juliacall  # noqa: F401\n    else:\n        import juliacall  # noqa: F401\n</code></pre>"},{"location":"reference/#poromics.julia_helpers.is_backend_installed","title":"<code>is_backend_installed(Main=None, error=False)</code>","text":"<p>Checks if Tortuosity.jl is installed.</p> <p>Parameters:</p> Name Type Description Default <code>Main</code> <code>ModuleValue</code> <p>Julia Main module. Default is None. If None, it will be initialized.</p> <code>None</code> <code>error</code> <code>bool</code> <p>If True, raises an error if backend is not found. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>True if the package is installed, False otherwise.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Julia is not installed or backend is not found and error is True.</p> Source code in <code>src/poromics/julia_helpers.py</code> <pre><code>def is_backend_installed(Main: \"juliacall.ModuleValue\" = None, error: bool = False) -&gt; bool:\n    \"\"\"Checks if Tortuosity.jl is installed.\n\n    Args:\n        Main: Julia Main module. Default is None. If None, it will be initialized.\n        error: If True, raises an error if backend is not found. Default is False.\n\n    Returns:\n        flag: True if the package is installed, False otherwise.\n\n    Raises:\n        ImportError: If Julia is not installed or backend is not found and error is True.\n    \"\"\"\n    Main = init_julia() if Main is None else Main\n    if import_package(\"Tortuosity\", Main, error=False) is not None:\n        return True\n    msg = \"Tortuosity.jl not found, run 'python -m poromics install'\"\n    if error:\n        raise ImportError(msg)\n    return False\n</code></pre>"},{"location":"reference/#poromics.julia_helpers.is_julia_installed","title":"<code>is_julia_installed(error=False)</code>","text":"<p>Checks that Julia is installed.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>bool</code> <p>If True, raises an error if Julia is not found. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>True if Julia is installed, False otherwise.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Julia is not installed and error is True.</p> Source code in <code>src/poromics/julia_helpers.py</code> <pre><code>def is_julia_installed(error: bool = False) -&gt; bool:\n    \"\"\"Checks that Julia is installed.\n\n    Args:\n        error: If True, raises an error if Julia is not found. Default is False.\n\n    Returns:\n        flag: True if Julia is installed, False otherwise.\n\n    Raises:\n        ImportError: If Julia is not installed and error is True.\n    \"\"\"\n    # Look for system-wide Julia executable\n    try:\n        find_julia()\n        return True\n    except Exception:\n        pass\n    # Look for local Julia executable (e.g., installed by juliapkg)\n    if can_skip_resolve():\n        return True\n    msg = \"Julia not found. Visit https://github.com/JuliaLang/juliaup and install Julia.\"\n    if error:\n        raise ImportError(msg)\n    return False\n</code></pre>"},{"location":"reference/#poromics.julia_helpers.remove_julia_env","title":"<code>remove_julia_env()</code>","text":"<p>Removes the active Julia environment directory.</p> <p>When Julia or its dependencies are corrupted, this is a possible fix.</p> Source code in <code>src/poromics/julia_helpers.py</code> <pre><code>def remove_julia_env() -&gt; None:\n    \"\"\"Removes the active Julia environment directory.\n\n    When Julia or its dependencies are corrupted, this is a possible fix.\n    \"\"\"\n    path_julia_env = Path(juliapkg.project())\n\n    if path_julia_env.exists():\n        logger.warning(f\"Removing Julia environment directory: {path_julia_env}\")\n        shutil.rmtree(path_julia_env)\n    else:\n        logger.warning(\"Julia environment directory not found.\")\n</code></pre>"},{"location":"usage/","title":"Basic usage","text":"<p>After installing <code>poromics</code>, you can use it in your Python scripts or Jupyter notebooks. The package provides a simple interface to calculate tortuosity using the <code>Tortuosity.jl</code> package. Here's a basic example of how to use it:</p> <p>Note</p> <p>The first time you import <code>poromics</code>, it will take a few minutes to install Julia and the required packages. This is a one-time setup.</p>"},{"location":"usage/#generate-a-test-image","title":"Generate a test image","text":"<p>You can use the <code>porespy</code> package to generate a test image. In this example, we will create a simple 2D image with <code>blobs</code>.</p> <pre><code># mkdocs: render\nimport porespy as ps\nimport matplotlib.pyplot as plt\n\nim = ps.generators.blobs(shape=[100, 100, 1], porosity=0.6, seed=42)\n\nfig, ax = plt.subplots()\nax.imshow(im[:, :, 0], cmap=\"viridis\", interpolation=\"nearest\")\nax.set_title(\"Boolean Image\")\n</code></pre>"},{"location":"usage/#perform-tortuosity-simulation","title":"Perform tortuosity simulation","text":"<pre><code>import poromics\n\nresult = poromics.tortuosity_fd(im, axis=1, rtol=1e-5, gpu=True)\nprint(result)\n</code></pre> <p>Result(\u03c4 = 7.18, axis = 1, variable D = False)</p> <p>The <code>Result</code> object is a simple container with the following attributes:</p> <ul> <li><code>im</code>: The tortuosity factor of the image.</li> <li><code>axis</code>: The axis along which the tortuosity was calculated.</li> <li><code>tau</code>: The tortuosity factor.</li> <li><code>c</code>: The concentration field.</li> </ul>"},{"location":"usage/#visualize-the-results","title":"Visualize the results","text":"<p>In addition to the tortuosity factor, <code>poromics</code> also provides the concentration field as a 2D/3D array, which can be useful, e.g., for training a machine learning model! You can visualize the concentration field using <code>matplotlib</code>.</p> <pre><code>fig, ax = plt.subplots()\ncax = ax.imshow(result.c[:, :, 0], cmap=\"viridis\", interpolation=\"nearest\")\nax.set_title(\"Concentration Field\")\ncbar = fig.colorbar(cax, ax=ax, fraction=0.046, pad=0.04)\ncbar.set_label(\"c [mol/m^3]\")\n</code></pre>"},{"location":"usage/#full-example","title":"Full example","text":"<pre><code>import poromics\nimport porespy as ps\nimport matplotlib.pyplot as plt\n\nim = ps.generators.blobs(shape=[100, 100, 1], porosity=0.6, seed=42)\n\nfig, ax = plt.subplots()\nax.imshow(im[:, :, 0], cmap=\"viridis\", interpolation=\"nearest\")\nax.set_title(\"Boolean Image\")\n\nresult = poromics.tortuosity_fd(im, axis=1, rtol=1e-5, gpu=False)\nprint(result)\n\nfig, ax = plt.subplots()\ncax = ax.imshow(result.c[:, :, 0], cmap=\"viridis\", interpolation=\"nearest\")\nax.set_title(\"Concentration Field\")\ncbar = fig.colorbar(cax, ax=ax, fraction=0.046, pad=0.04)\ncbar.set_label(\"c [mol/m^3]\")\n</code></pre>"}]}